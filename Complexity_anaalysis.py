# 2.2.1迭代
### 迭代是一种重复执行某个任务的控制结构。会在满足一定的条件下重复执行某段代码，直到条件不再满足。
#### 1.for 循环 适合在预先知道迭代的次数时使用。
# 求 1 + 2 +...+n的和 思考：如何计算？ 给定一个n值，计算1-n的和，首先需要声明一个初始值 res 用于存储每一次的计算结果；
# 那么如何判断计算是否在n以内呢？需要指定另一个变量 i ，每一次做完加法后，对该变量+1，+1后的值用于判断是否在n以内。
def for_loop(n: int) -> int:
    res = 0
    for i in range(1, n + 1):
        res += i  # 等同于 res = res + i
        # res = res + i
    return res

#### 2.while循环 while循环比for循环自由度更高
def while_loop(n: int) -> int:
    res = 0
    i = 1
    while i <= n:
        res += i
        i += 1 # 这一步相当于声明间隔步骤
    return res

# 如果想计算 1- n之间偶数的和呢？
def while_loop_en(n: int) -> int:
    res = 0
    i = 0
    while i <= n:
        res += i
        i += 2
    return res

#### 3.嵌套循环 可以在循环内部再嵌套一个循环结构
def nested_for_loop(n : int) -> str:
    res = ""
    for i in range(1,n+1):
        for j in range(1,n+1):
            res += f"({i},{j}),"
            resa = i +j
    return res,resa
# print(nested_for_loop(5))

# 2.2.2递归
### 递归是一种方法策略，通过函数调用自身来解决问题，主要包含两个阶段
### 1：递（程序不断地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”;
### 2：归（触发终止条件后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果）
### 递归通常包含三个要素：
#### 1、终止条件：用于决定什么时候由“递”转“归”；
#### 2、递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数
#### 3、返回结果：对应“归”，将当前递归层级的结果返回至上一层

def recur(n : int) ->int:
    if n==1:
        return 1
    res = recur(n - 1)
    return n+res
# print(recur(5))

#### 迭代：“自下而上”的解决问题。从最基础的步骤开始，不断重复或累加完成这些步骤，直到任务完成；
#### 递归：“自下而上”的解决问题。将原问题分为更小的子问题，子问题和原问题具有相同的形式。接下来将子问题继续分为更小的问题，直到基本情况时停止。
##### 1、调用栈 递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息，这将导致两方面结果：
######      ①函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更耗费内存空间。
######      ②递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。递归深度通常是有限的，过身的递归可能导致栈溢出错误；


#### 2、尾递归：如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或者解释器优化，使其在空间效率上与迭代相当。称为尾迭代。
###### 普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
###### 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无需保存上一层函数的上下文。

def tail_recur(n : int,res: int  ) -> (int,int):
    if n== 0:
        return res
    return tail_recur( n -1,res + n)
# print(tail_recur(2,5))

# 输入 2，5 ;当n等于2时，返回 函数tail_recur(2-1,5+2) -> tail_recur(1,7)
## 那么tail_recur(1,7)的值仍然需要递进原函数求值 当n等于1的时候，返回 tail_recur(0,8)
## 求tail_recur(0,8),当n等于0，res等于8的时候，返回res得到 8，最终返回8

### 3.递归树 当处理“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。
#### 以“斐波那契”数列为例 给定一个斐波那契数列0,1,1,2,3,5,8,13...求该数列的第n个数字。
#### 设斐波那契的第n个数为f(n),易得到两个结论
##### ①数列的前两个数字f(1)=0,f(2)=1
##### ②数列中的每个数字是前两个数字的和，即f(n) = f(n-1) +f(n-2)
def leFibanacci(n: int) -> int:

    if n==1 or n==2:
        return n-1
    return  leFibanacci(n-1) + leFibanacci(n-2)


#### 递归适合处理链表、树和图相关问题，因为他们非常适合用分治思维进行分析


def for_loop_recur(n: int) -> int:
    """使用迭代模拟递归"""
    # 使用一个显式的栈来模拟系统调用栈
    stack = []
    res = 0
    # 递：递归调用
    for i in range(n, 0, -1):
        # 通过“入栈操作”模拟“递”
        stack.append(i)
    # 归：返回结果
    while stack:
        # 通过“出栈操作”模拟“归”
        res += stack.pop()
    # res = 1+2+3+...+n
    return res
print(for_loop_recur(7))

# 2.3时间复杂度
## 运行时间可以直观且准确的反应算法的效率。可通过以下步骤预估代码运行时间
### ① 确定运行平台 、② 评估各种计算操作所需的运行时间、③ 统计代码中所有的操作。

## 2.3.1 统计时间增长趋势
### 时间复杂度分析统计的不是算法运行时间,而是算法运行时间随着数据量变大时的增长趋势
### 常数阶时间复杂度：算法运行时间不随着n增大而增大
### 线性阶时间复杂度：算法运行时间随着n增大而线性增长
### 常数阶时间复杂度：