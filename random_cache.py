## 内存和缓存
## 物理结构在很大程度上决定了程序对内存和缓存的使用效率。
## 4.4.1 计算机存储设备
## 包括三种类型的存储设备：硬盘、内存、缓存
## 硬盘：长期存储数据，包括操作系统、程序、文件等； 断电后不会丢失；
## 内存：临时存储当前运行的程序和正在处理的数据；断电后数据丢失；
## 缓存：存储经常访问的数据和指令，减少CPU访问内存的次数；断电后数据丢失；
## 总结：硬盘用于长期存储大量数据，内存用于临时存储程序运行中正在处理的数据，而缓存则用于存储经常访问的数据和指令；

## 4.4.2 数据结构的内存效率
## 内存是有限的，且同一块内存不能被多个程序共享；链表相对于数组更为灵活，因为内存不连续；但是碎片化也更高；
## 4.4.3 数据结构的缓存效率
## 缓存命中越少，CPU读写数据的效率就越高；缓存命中率：CPU从换从中成功获取数据的比例；
## 通过以下方式可以提高缓存的效率
## 缓存行：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。缓存行相对于缓存单个字节更为高效
## 预取机制：处理器会尝试预测数据访问模式，并根据特定的模式将数据加载至缓存中，从而提升命中率
## 空间局部性：如果一个数据被访问，那么它附近的数据也可能被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率
## 时间局部性：如果一个数据被访问，那么她在将来很有可能再被访问。缓存利用这一原理，通过保留最近访问的数据来提高命中率。

## 实际上，数组和链表对缓存的利用效率是不同的，主要体现在：
## 占用空间：链表元素比数组元素占用空间更多，导致内存中容纳的有效数据更少
## 缓存行：链表数据分散在内存各处，而缓存是“按行加载的”，因此加载到无效数据的比例更高
## 预取机制：数组比链表的数据访问模式更具 “可预测性”，系统更容易猜出即将被加载的数据
## 空间局部性：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问
### 总体而言：数组具有更高的缓存命中率，因此它在操作效率上通常优于链表；

# class Solution(object):
#     def twoSum(self, nums, target):
#         """
#         :type nums: List[int]
#         :type target: int
#         :rtype: List[int]
#         """
#         for i in range(len(nums)-1):
#             nums[i] += nums[i + 1]
#             while nums[i] == target:
#                 return i, i + 1


